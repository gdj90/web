<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>IndexedDB 예제</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; }
    h1 { font-size: 18px; }
    input, button { padding: 6px 10px; }
    #list { margin-top: 10px; }
    .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; }
    .item { padding: 6px 8px; border: 1px solid #ddd; border-radius: 6px; }
  </style>
</head>
<body>
  <h1>IndexedDB (웹 DB) — 메모 추가/보기/삭제</h1>
  <!-- 입력 영역 : 저장할 텍스트를 입력 후 추가 클릭 => db에 내용 저장 -->
  <div class="row">
    <input id="text" placeholder="메모를 입력하세요" />
    <button id="add">추가</button>
    <button id="clear">전체 삭제</button>
  </div>
  <!-- 출력 영역 : db에서 읽은 부분 출력 -->
  <div id="list"></div>

  <script>
    const DB_NAME = 'simple-db';  // 데이터베이스 이름.
    const DB_VERSION = 1;         // 버전값
    const STORE = 'items';        //컬럼 : {id(키값), text, 저장시간}
    //fnElement 함수
    const fnElement = (id) => document.getElementById(id); //id="id값" : id값을 가진 태그 리턴
    /* 
        function(id) {return document.getElementById(id); }
    */
    // 입력영역
    const textEl = fnElement('text'); // <input id="text" placeholder="메모를 입력하세요" />
    // 출력영역
    const listEl = fnElement('list'); // <div id="list"></div>

    function openDB() {
        //Promise 객체 반환 : await openDB() 형태로 완료시점까지 대기가 가능
      return new Promise((resolve, reject) => {
        //indexedDB.open(데이터베이스명,버전값)  : db 사용 준비
        const req = indexedDB.open(DB_NAME, DB_VERSION);

        req.onupgradeneeded = (e) => {  //처음이거나, 로드되는 경우 실행됨
          const db = e.target.result;
          if (!db.objectStoreNames.contains(STORE)) {
            db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true }); //items 객체 생성
          }
        };
        req.onsuccess = () => resolve(req.result); // 성공 인경우 db
        req.onerror = () => reject(req.error);     // 오류발생. 오류 객체 전달
      });
    }
    function withStore(db, mode, fn) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE, mode); //db 모드 설정 : readonly, readwrite
        const store = tx.objectStore(STORE);
        let result;
        try { result = fn(store); } catch (err) { reject(err); }
        tx.oncomplete = () => resolve(result);
        tx.onerror = () => reject(tx.error);
      });
    }
    //CRUD (create, read, update, delete)
    function addItem(db, text) { //create 기능
      return withStore(db, 'readwrite', (store) => {
        return new Promise((resolve, reject) => {
          const data = { text, createdAt: Date.now() }; //db에 저장할 데이터
          const req = store.add(data); //db 등록
          req.onsuccess = () => resolve(req.result); //add 성공
          req.onerror = () => reject(req.error);     //add 실패
        });
      });
    }
    function getAll(db) {
        //읽기 전용으로 db 접근
      return withStore(db, 'readonly', (store) => {
        return new Promise((resolve, reject) => {
          const req = store.getAll(); //현재 등록된 내용을 조회
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      });
    }
    function clearAll(db) {
      return withStore(db, 'readwrite', (store) => {
        return new Promise((resolve, reject) => {
          const req = store.clear(); //전체 db의 내용을 제거
          req.onsuccess = () => resolve(); //성공시 전달 내용 없음
          req.onerror = () => reject(req.error); //오류 발생
        });
      });
    }

    function render(items) {
        //items : db에서 읽은 내용들
      if (!items.length) { //db에 내용 없는 경우
        listEl.innerHTML = '<div class="item">아직 데이터가 없습니다.</div>';
        return;
      }
      const rows = items
        .sort((a, b) => b.id - a.id)  //id의 값이 큰값부터. 내림차순정렬
        .map  //리스트의 요소를 변경
(it => `<div class="item">#${it.id} — ${escapeHtml(it.text)} <small>(${new Date(it.createdAt).toLocaleString()})</small></div>`)
        .join('');
        //toLocaleString() : 지역에 맞는 날짜 형식으로 출력
      listEl.innerHTML = rows;
    }

    //s : 입력 내용. 보안에 관련된 내용. &nbsp; => 순수한 문자로 변경
    /*
     s : "안녕하세요" => {'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'}["]
         &quot;안녕하세요&quot;
    /[&<>"']/g : &,<,>,",' 문자를 변경시킴. /g : 모두변경. 
      => s문자열에서 & < > " ' 문자를 모두 변경하기.
    */
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, ch => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      })[ch]);
    }

    //실행 시작
    (async function init() { //비동기함수. await 예약어 사용은 async 함수에서만 사용이 가능함
      try { //오류 발생 가능성이 있는 문장들
        const db = await openDB(); //await : 대기. db가 오픈 될때 까지  대기
        render(await getAll(db));
        fnElement('add').addEventListener('click', async () => {  //추가 버튼 클릭시 이벤트 처리
          try {
            const text = textEl.value.trim(); //입력 정보
            if (!text) return;  //입력 내용이 없으면 return
            await addItem(db, text); //db에 등록
            textEl.value = ''; //입력란 초기화
            render(await getAll(db)); //전체 데이터 조회 
          } catch (err) {
            alert('추가 중 오류가 발생했습니다: ' + (err?.message || err));
          }
        });
        fnElement('clear').addEventListener('click', async () => {  //전체 삭제 버튼 클릭시 이벤트 처리
          try {
            await clearAll(db);
            render(await getAll(db));
          } catch (err) {
            alert('삭제 중 오류가 발생했습니다: ' + (err?.message || err));
          }
        });
      } catch (err) {  //reject 된경우 실행
        //err?.message || err : err.message :오류 객체의 메세지
        // => err 객체 존재하면 .message 출력. 오류발생시 err 출력 
        alert('데이터베이스 초기화 실패: ' + (err?.message || err));
      }
    })();
  </script></body></html>
